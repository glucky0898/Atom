
<!-- TOC -->

- [包](#包)
- [多态，继承，接口](#多态继承接口)
- [异常处理](#异常处理)
- [字符串](#字符串)
- [反射，注解](#反射注解)
- [容器](#容器)
- [I/O系统](#io系统)
- [并发](#并发)

<!-- /TOC -->
#### 包
   - import static
     >后面跟上变量全路径，在代码中就可直接使用静态变量，不需要使用类.静态变量的形式获取变量

#### 多态，继承，接口



#### 异常处理
  - 捕获异常throw
  ```java
    //给异常添加信息，Exception有两种构造器，一个无参，一个string参数
    if(###)
    throw new Exception("出错误");//throw 类似return 方法
    //输出参数值
    catch(Exception e) e.printStackTrace();
    //或自定义异常类BusinessException，需extends Exception
    catch(Exception e) throw new BusinessException("redis读取数据失败");
  ```
  > 输出异常信息详细度：e.getMessage()<e.getLocalizedMessage()<toString()<e.printStackTrace()
  - 抛出异常(异常说明)throws
    >编译时被强制检查的异常称为被检查的异常,runtimeexception不需要捕获，是特例，自己会抛出
  ```java
    method() throws Exception{}//告知调用者可能会抛出异常
  ```
  - 基类，子类抛出异常说明
    基类构造器有异常说明，子类构造器必须包含父类构造器的异常说明。子类方法覆盖父类方法时，父类方法的没有异常说明，子类不能有。父类有异常说明，子类可没有或者子类的异常说明是父类异常说明的子类，总而言之，同继承相反，范围要变小。
  -

    在创建需要清理的对象后，立即创建内层的try-catch块。外部其他异常，内部针对对象的清理时的异常[]
#### 字符串
  - **String**
    String str = "a"+"b"+"c";
    > 反编译后可看出是编译器自动生成StringBuidler,使用append()方法，一个个添加，最后toString();
    ```Java
      String result = "";
      for(int i=0;i<fields.length;i++){
        result += fileds[i];//重载"+"操作符
      return result
    }
    ```
    > 1.result应该使用StringBuilder，因为使用String,每次循环重载时，一个循环就创建一个StringBuilder
    > 2.对String类型操作，若为true，返回的是新的对象，原先对象不改变。为false,则返回原先对象，节省了存储空间和避免开销
  - **String，StringBuilder，StringBuffer三者的区别:**
    1.执行速度：StringBuilder > StringBuffer > String
    2.String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢
      str=str+"de";
      //JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了
    3.StringBuilder是线程不安全的(用在对大量字符串操作的单线程中)，而StringBuffer是线程安全的(用在多线 程中). 两个都可以改变自身。String用在少量的字符串操作的情况
  - **正则表达式**
    1.正则表达式与其他语言对反斜线的处理不同，例如：其他语言："\d",java:"\\d"。如果想插入一个普通反斜线使用："\\\\"。而换行符、制表符之类的只需要使用"\n","\t"。若要添加普通的"+"号，需要转义："\\+"
    ```java
    Pattern p = new Pattern("rexString");//正则表达式
      Matcher m = p.matcher("goalString");//需要匹配的字符串
      while(m.find()){//find():迭代向前遍历匹配  m.find(i)则以下标i为搜索起始点【都以最初的goalString的起始点]
      m.group();//m。group(1) m.group(2) 对应多个圆括号匹配的内容
      ===============================================================
        while(m.find()){
        for(int i = 0;i<= m.groupCount();i++){
            m.group(i);
        }
      }
        //只返回匹配的部分;  m.group(i):匹配成功后形式为(A(B(C))D) ABCD第0组即默认的m.group();BC为第1组，即在ABCD为goalString时，匹配的结果；C为第2组，即BC为goalString时匹配的结果[rexString不变]
      ===============================================================
    }
    ```
    > m.matches():整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。但如果前部分匹配成功,将移动下次匹配的位置(即多次使用matches方法时，goalString匹配位置从上次匹配的末尾开始匹配)。
      m.lookingA()t:部分匹配，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。(多次调用，匹配的位置依然是最原先goalString的位置开始)
      m.find():部分匹配，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。
      m.reset():给当前的Matcher对象配上个新的目标，目标是就该方法的参数；如果不给参数，reset会把Matcher设到当前字符串的开始处
#### 反射，注解

#### 容器
  - 集合类的迭代遍历
    -  List Set
    ```java
      ArrayList<Integer> list = new ArrayList<Integer>();
      Iterator iterator = list.iterator();
      while(iteratro.hasNext()){
        Integer id = iterator.next();
      }
    ```
    - Map
      >HashMap的遍历有两种常用的方法，那就是使用keyset及entryset来进行遍历，但两者的遍历速度是有差别的.对于keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于的value。而entryset只是遍历了第一次，他把key和value都放到了entry中，所以就快了

    ```java
    HashMap<String,String> map = new HashMap<>();
    Iterator iterator = map.keySet().iterator();
    while(iterator.hashNext()){
      Object key = iterator.next();
      Object value = map.get(key);
    }
    ```
    ```java
    Iterator iterator = map.entrySet().iterator();
    while(iterator.hasNext()){
      Map.Entry entry = (Map.Entry)iterator.next();
      Obeject key = entry.getKey();
      Object value = entry.getValue();
    }
    ```
  - 排序
    - 类对象实现comparable重写compareTo方法
    ```java
        1.  public class User implements Comparable<User>
        2.  public int compareTo(User o) {  
           int i = this.getAge() - o.getAge();//先按照年龄排序  
           if(i == 0){  
               return this.score - o.getScore();//如果年龄相等了再用分数进行排序  
           }  
           return i;  
       }  
       3. Collections.sort(users);//如果是基本类型，则只需要这个
    ```
      - 使用sort(List<T> list, Comparator<? super T> c)
    ```java
    Collections.sort(students, new Comparator<Students>() {  

            @Override  
            public int compare(Students o1, Students o2) {  
                int i = o1.getScore() - o2.getScore();  
                if(i == 0){  
                    return o1.getAge() - o2.getAge();  
                }  
                return i;  
            }  
        });
    ```
    ```java
     使用java的lambda表达式
     arrList.sort((className a,className b)-> a.getAge()-b.getAge())
    ```
#### I/O系统

#### 并发
